// most important time 
// inser and delete : o(log(n)) (add, delete and remove)find
// binary tree binary search tree
//value  limitation unbalanced binary tree
// left : small , Right : Bigger
// unbalanced binary tree : o(n)
// balanced tree should be for the 
// self balanced binary tree
// inefficient for sorted data
// Real case : file system , Databases , Networking protocol
// mathematical problem, machine learning DTS (deason tree)
// compression of files
// future data structures (heaps)
// size: total number of nodes
// child and Parent
// siblings
// edge :connected line
// height : number of edges between two nodes
// degree : 0, 2
// leaf node : bottom nodes
// level : height height of root - height of node 
// ancestor & descendant
// Types of Binary tree
// Complete Binary tree : All Level Full and last fill from left to Right
// strict Binary tree / full tree: either 0 or 2 children /compression / segmet tree
// Perfect tree : All levels are full
// height balanced Avg hright 0(log(n))
// skewed BT : every node have 1 child : height : O(n)
// ordered Binary tree
// Every Node has some property
// example BST
// Properties : 
// perfect Binary height  = n
// total nodes = 2 ^(n +1 ) -1 (Gommetric Progression)
// perfect binary tree : leaf nodes = 2 ^ height
// number of internal nodes = 2 ^ h +1 - 1 - 2^ h = 2^h - 1
// n = number of Leaves
// log n + 1 levels atleast
// n number of Nodes = log (n + 1)
// strict binary tree = total leaves = n - 1
// for strict : no of leaf nodes = internal nodes + 1
// insert : left or root


